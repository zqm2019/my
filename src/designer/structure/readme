/**
* 结构模式
*   1. 适配器模式
*         目的：适配器将某个接口转换成客户端期望的另一个接口表示，消除了由于接口不匹配🔐造成的类的兼容性问题
*         分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式
*   2. 装饰模式
*        定义:给一个对象动态的增加新的功能，要求装饰对象和被装饰的对象实现同一接口，装饰对象持有被装饰对象的实例。拥有被装饰类为参数的构造器
*           装饰器模式的应用场景：
*           1、需要扩展一个类的功能。
*           2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）
*          缺点：产生过多相似的对象，不易排错！
*   3. 代理模式
*       定义：给一个对象动态的增加新的功能，要求装饰对象和被装饰的对象实现同一接口，装饰对象持有被装饰对象的实例。默认构造器提供获取被装饰属性的方法
*           代理模式的应用场景：
*           如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
*            1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
*            2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
*         好处：使用代理模式，可以将功能划分的更加清晰，有助于后期维护！
*
*   4. 外观模式
*       外观模式是为了解决类与类之家的依赖关系的（像spring一样，可以将类和类之间的关系配置到配置文件中），
*       而外观模式就是将他们的关系放在一个Facade类中，降低了类与类之间的耦合度，该模式中没有涉及到接口
*   5. 桥接模式
*       将事物和具体实现分开，既将抽象化和实现化解耦，使得二者可以独立变化。
*       对外的接口是一样的（桥不变，如电脑的usb接口）可以连接不同的外设（电脑自动识别，装不同的驱动），
*   6. 组合模式
*   7. 亨元模式
*
*/