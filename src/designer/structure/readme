/**
* 结构模式
*   1. 适配器模式
*         目的：适配器将某个接口转换成客户端期望的另一个接口表示，消除了由于接口不匹配🔐造成的类的兼容性问题
*         分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式
*   2. 装饰模式
*        定义:给一个对象动态的增加新的功能，要求装饰对象和被装饰的对象实现同一接口，装饰对象持有被装饰对象的实例。拥有被装饰类为参数的构造器
*           装饰器模式的应用场景：
*           1、需要扩展一个类的功能。
*           2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）
*          缺点：产生过多相似的对象，不易排错！
*   3. 代理模式
*       定义：给一个对象动态的增加新的功能，要求装饰对象和被装饰的对象实现同一接口，装饰对象持有被装饰对象的实例。默认构造器提供获取被装饰属性的方法
*           代理模式的应用场景：
*           如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
*            1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
*            2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
*         好处：使用代理模式，可以将功能划分的更加清晰，有助于后期维护！
*
*   4. 外观模式
*       外观模式是为了解决类与类之家的依赖关系的（像spring一样，可以将类和类之间的关系配置到配置文件中），
*       而外观模式就是将他们的关系放在一个Facade类中，降低了类与类之间的耦合度，该模式中没有涉及到接口
*   5. 桥接模式
*       将事物和具体实现分开，既将抽象化和实现化解耦，使得二者可以独立变化。
*       对外的接口是一样的（桥不变，如电脑的usb接口）可以连接不同的外设（电脑自动识别，装不同的驱动），
*   6. 组合模式
*       整体和部分的关系；组合对象
*            组合模式，就是在一个对象中包含其他对象，这些被包含的对象可能是终点对象（不再包含别的对象），也有可能是非终点对象
*           （其内部还包含其他对象，或叫组对象），我们将对象称为节点，即一个根节点包含许多子节点，这些子节点有的不再包含子节点，
*            而有的仍然包含子节点，以此类推,类似于树的节点。
*   7. 亨元模式 与工厂模式一起使用
*       主要用于减少创建对象的数量，以减少内存占用和提高性能；它提供了减少对象数量从而改善应用所需的对象结构的方式。
*       享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象
*   享元模式可以再次创建对象 也可以取缓存对象
*   单例模式则是严格控制单个进程中只有一个实例对象
*   享元模式可以通过自己实现对外部的单例 也可以在需要的使用创建更多的对象
*   单例模式是自身控制 需要增加不属于该对象本身的逻辑
*/